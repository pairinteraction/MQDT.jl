var documenterSearchIndex = {"docs":
[{"location":"#MQDT","page":"Home","title":"MQDT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MQDT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MQDT.BasisArray","page":"Home","title":"MQDT.BasisArray","text":"See also basisarray, BasisState\n\nBasisArray(states::Vector{BasisState})\n\nType to store a basis. A basis is a list of BasisState types, typically corresponding to different Rydberg series. BasisArray is generated by the basisarray function using lists of Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.BasisState","page":"Home","title":"MQDT.BasisState","text":"See also basisarray, BasisArray, EigenStates\n\nBasisState(\n    species::Symbol,\n    energy::Float64,\n    parity::Int,\n    f::Float64,\n    nu::Vector{Float64},\n    lr::Vector{Int},\n    coeff::Vector{Float64},\n    channels::Channels,\n    term::String,\n    lead::Float64,\n    L::Float64,\n    S::Float64,\n)\n\nType to store all relevant information of multi-channel bound states for a given Rydberg series. BasisState is generated by the basisarray function using a Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Channels","page":"Home","title":"MQDT.Channels","text":"See also lsChannels, jjChannels, fjChannels\n\nAbstract type to store the quantum numbers of an MQDT channel representation.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.EigenStates","page":"Home","title":"MQDT.EigenStates","text":"See also eigenstates, BasisState\n\nEigenStates(n::Vector{Float64}, nu::Matrix{Float64}, a::Matrix{Float64})\n\nType to store multi-channel bound states. n is a global energy reference to a global threshold specified in the Parameters type. nu is the principal quantum number in each channel with respect to the channel-specific threshold. a is the coefficient of each channel contributing to the bound state. EigenStates is populated by the eigenstates function.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Model","page":"Home","title":"MQDT.Model","text":"See also fModel, kModel\n\nAbstract type to store MQDT models.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Parameters","page":"Home","title":"MQDT.Parameters","text":"Parameters(species::Symbol, mass::Float64, spin::Float64, rydberg::Float64, threshold::Float64, hyperfine::Float64, dipole::Float64)\n\nType to store relevant parameters for each atomic element. A corresponding file in the parameters folder of the mqdt module initializes this type.\n\nExamples\n\njulia> PARA = Parameters(\n           :Yb174,\n           1822.88848628*173.9388621, # nuclear mass\n           0, # nuclear spin\n           109736.9695858, # Rydberg constant in 1/cm\n           50443.070393, # lowest ionization threshold in 1/cm\n           0, # hyperfine constant in 1/cm\n           2.1, # nuclear dipole\n       );\n\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.QuantumNumbers","page":"Home","title":"MQDT.QuantumNumbers","text":"See also lsQuantumNumbers, jjQuantumNumbers, fjQuantumNumbers\n\nAbstract type to store the quantum numbers of an MQDT channel representation.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fModel","page":"Home","title":"MQDT.fModel","text":"See also kModel\n\nfModel(\n    species::Symbol,\n    name::String,\n    size::Int,\n    terms::Vector{String},\n    core::Vector{Bool},\n    thresholds::Vector{Float64},\n    defects::Matrix{Float64},\n    mixing::Vector{String},\n    angles::Matrix{Float64},\n    inner_channels::Channels\n    outer_channels::Channels\n    unitary::Matrix{Float64}\n)\n\nType to store MQDT models inspired by [PRX 15, 011009 (2025)] using sparse K matriced and frame transformation. Contains all relevant parameters to form the K matrix and calculate the spectrum for a specific Rydberg series.\n\nExamples\n\njulia> RYDBERG_S0 = fModel(\n           :Yb174,\n           \"S J=0, ν > 2\", # fit for states 6s7s upward [Phys. Rev. X 15, 011009 (2025)]\n           6,\n           [\"6sns 1S0\", \"4f13 5d 6snl a\", \"6pnp 1S0\", \"4f13 5d 6snl b\", \"6pnp 3P0\", \"4f13 5d 6snl c\"],\n           Bool[1, 0, 1, 0, 1, 0],\n           [50443.070393, 83967.7, 80835.39, 83967.7, 77504.98, 83967.7],\n           [\n               0.355097325 0.278368431;\n               0.204537279 0;\n               0.116394359 0;\n               0.295432196 0;\n               0.25765161 0;\n               0.155807042 0\n           ],\n           [\"12\", \"13\", \"14\", \"34\", \"35\", \"16\"],\n           [0.12654859 0; 0.30010744 0; 0.05703381 0; 0.11439805 0; 0.09864375 0; 0.14248210 0],\n           lsChannels([\n               lsQuantumNumbers(0.5, 0, 0, 0, 0, 0),\n               lsQuantumNumbers(0.5, 0, 1, 1, 0, 0),\n               lsQuantumNumbers(0.5, 1, 1, 1, 1, 0),\n           ]),\n           jjChannels([\n               jjQuantumNumbers(0.5, 0, 0.5, 0, 0.5, 0),\n               jjQuantumNumbers(0.5, 1, 0.5, 1, 1.5, 0),\n               jjQuantumNumbers(0.5, 1, 0.5, 1, 0.5, 0),\n           ]),\n           [\n               1 0 0 0 0 0;\n               0 1 0 0 0 0;\n               0 0 -sqrt(2/3) 0 sqrt(1/3) 0;\n               0 0 0 1 0 0;\n               0 0 sqrt(1/3) 0 sqrt(2/3) 0;\n               0 0 0 0 0 1\n           ],\n       );\n\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fjChannels","page":"Home","title":"MQDT.fjChannels","text":"See also lsChannels, jjChannels\n\nfjChannels(i::Vector{fjQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"fj\" (sometimes called \"fragmentation\") coupling scheme\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fjQuantumNumbers","page":"Home","title":"MQDT.fjQuantumNumbers","text":"See also lsQuantumNumbers, jjQuantumNumbers\n\nfjQuantumNumbers(sc::Float64, lc::Int, Jc::Float64, Fc::Float64, lr::Int, Jr::Float64, F::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"fj\" (sometimes called \"fragmentation\") coupling scheme, i.e. core angular momentum quantum numbers are coupled to the nuclear spin to give a core hyperfine configuration (Fc) which is coupled to the total Rydberg angular momentum (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.jjChannels","page":"Home","title":"MQDT.jjChannels","text":"See also lsChannels, fjChannels\n\njjChannels(i::Vector{jjQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"jj\" coupling scheme, i.e. core and Rydberg angular momentum (AM) quantum numbers are coupled separately to give a total core AM (Jc) and total Rydberg AM (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.jjQuantumNumbers","page":"Home","title":"MQDT.jjQuantumNumbers","text":"See also lsQuantumNumbers, fjQuantumNumbers\n\njjQuantumNumbers(lc::Int, Jc::Float64, lr::Int, Jr::Float64, J::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"jj\" coupling scheme, i.e. core and Rydberg angular momentum (AM) quantum numbers are coupled separately to give a total core AM (Jc) and total Rydberg AM (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.kModel","page":"Home","title":"MQDT.kModel","text":"See also fModel\n\nkModel(\n    species::Symbol\n    name::String\n    size::Int\n    terms::Vector{String}\n    jjscheme::Vector{Bool}\n    lschannels::lsChannels\n    jjchannels::jjChannels\n    thresholds::Vector{Float64}\n    K0::Matrix{Float64}\n    K1::Vector{Float64}\n)\n\nType to store MQDT models inspired by [JPB 47, 155001 (2014)] using dense, energy-dependent K matrices. Contains all relevant parameters to form the K matrix and calculate the spectrum for a specific Rydberg series.\n\nExamples\n\njulia> KMODEL_S0 = kModel(\n           :Sr88,\n           \"1S0\",\n           3,\n           [\"(5s1/2)(ns1/2)\", \"(4d5/2)(nd5/2)\", \"(4d3/2)(nd3/2)\"],\n           Bool[1, 1, 1],\n           lsChannels([\n               lsQuantumNumbers(0.5, 0, 0, 0, 0, 0),\n               lsQuantumNumbers(0.5, 0, 2, 2, 0, 0),\n               lsQuantumNumbers(0.5, 0, 2, 2, 0, 0),\n           ]),\n           jjChannels([\n               jjQuantumNumbers(0.5, 0, 0.5, 0, 0.5, 0),\n               jjQuantumNumbers(0.5, 2, 2.5, 2, 2.5, 0),\n               jjQuantumNumbers(0.5, 2, 1.5, 2, 1.5, 0),\n           ]),\n           [45932.2002, 60768.43, 60488.09],\n           [\n               1.051261 0.3759864 -0.02365485;\n               0.3759864 -0.6400925 -0.0002063825;\n               -0.02365485 -0.0002063825 3.009087\n           ],\n           [0.8763911, 0.4042584, 17.22631],\n       );\n\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.lsChannels","page":"Home","title":"MQDT.lsChannels","text":"See also jjChannels, fjChannels\n\nlsChannels(i::Vector{lsQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"LS\" coupling scheme, i.e. core and Rydberg angular momentum quantum numbers are coupled individually to give a total spin (S) and total orbital angular momentum (L).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.lsQuantumNumbers","page":"Home","title":"MQDT.lsQuantumNumbers","text":"See also jjQuantumNumbers, fjQuantumNumbers\n\nlsQuantumNumbers(S::Float64, lc::Int, lr::Int, L::Int, J::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"LS\" coupling scheme, i.e. core and Rydberg angular momentum quantum numbers are coupled individually to give a total spin (S) and total orbital angular momentum (L).\n\n\n\n\n\n","category":"type"},{"location":"#LinearAlgebra.nullspace-Tuple{Vector{Float64}, Matrix}","page":"Home","title":"LinearAlgebra.nullspace","text":"nullspace(n::Vector{Float64}, M::Matrix)\n\nReturns the nullspace of the M matrix, which corresponds to the channel coefficents for an MQDT bound state.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G1-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G1","text":"G1(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G2-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G2","text":"G2(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G3-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G3","text":"G3(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G4-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G4","text":"G4(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G5-Tuple{fjQuantumNumbers, fjQuantumNumbers, Any}","page":"Home","title":"MQDT.G5","text":"G5(q1::fjQuantumNumbers, q2::fjQuantumNumbers, ic)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G6-Tuple{fjQuantumNumbers, fjQuantumNumbers, Any}","page":"Home","title":"MQDT.G6","text":"G6(q1::fjQuantumNumbers, q2::fjQuantumNumbers, ic)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G7-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G7","text":"G7(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G8-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G8","text":"G8(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.angular_matrix_cached-Tuple{Int64, MQDT.Channels, MQDT.Channels}","page":"Home","title":"MQDT.angular_matrix_cached","text":"See also angular_moment\n\nangular_matrix_cached(k::Int, k1::Channels, k2::Channels)\n\nIterates angular_moment over Channels, returns a matrix. This function is cached using the LRUCache package.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.angular_moment-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.angular_moment","text":"See also angular_matrix_cached\n\nangular_moment(k, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\nangular_moment(k, q1::jjQuantumNumbers, q2::jjQuantumNumbers)\nangular_moment(k, q1::lsQuantumNumbers, q2::lsQuantumNumbers)\n\nReturns the angular matrix elements (i.e. an analytically evaluated integral of spherical harmonics). Formula is found in Robicheaux2018 Eq. 20 and in Vaillant2014 Eq. C3\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.basisarray-Tuple{EigenStates, fModel}","page":"Home","title":"MQDT.basisarray","text":"basisarray(T::EigenStates, M::fModel)\nbasisarray(T::Vector{EigenStates}, M::Vector{fModel})\n\nFunction that generates all relevant bound-state data. Returns a BasisArray, which is a list of BasisState instances.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.beta-Tuple{Any, Any}","page":"Home","title":"MQDT.beta","text":"beta(N, L) = π .* (N .- L)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.couple-Tuple{String}","page":"Home","title":"MQDT.couple","text":"couple(C::String)\n\nFrom a string of type \"ij\", return a touple of indices (i, j). With this method, maximum for j is 10.\n\nExamples\n\nMQDT.couple(\"710\")\n\n# output\n\n(7, 10)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.eigenenergies-Tuple{Number, Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.eigenenergies","text":"See also mroots\n\neigenenergies(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns both the roots of the M matrix as well as the channel-dependent principal quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.eigenstates-Tuple{Number, Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.eigenstates","text":"See also eigenenergies\n\neigenstates(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns the bound states corresponding to an MQDT model in the form of an instance of EigenStates, which contains the global reference principal quantum number, the channel-dependent principal quantum numbers, as well as the channel coefficients.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_ic-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_ic","text":"element_ic(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core nuclear spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_lc-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_lc","text":"element_lc(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core orbital anugular momentum (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_lr-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_lr","text":"element_lr(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of Rydberg orbital anugular momentum (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_sc-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_sc","text":"element_sc(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_sr-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_sr","text":"element_sr(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of Rydberg spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.epsilon-Tuple{Any, Any, Any}","page":"Home","title":"MQDT.epsilon","text":"epsilon(N, T, R)\nepsilon(N, P::Parameters)\n\nGiven a principal quantum number, return the energy, depending on the ionization thresholds and the Rydberg constant.\n\nExamples\n\nϵ = MQDT.epsilon(60, 50443.217463, 109736.9635066)\n\n# output\n\n50412.734973137056\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.get_radial_state_cached-Tuple{Symbol, Float64, Int64}","page":"Home","title":"MQDT.get_radial_state_cached","text":"get_radial_state_cached(species::Symbol, nu::Float64, l::Int64)\n\nGet a rydberg state from the rydstate package and calculate its wavefunction. This function is cached using the LRUCache package.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.good_quantum_number-Tuple{lsChannels}","page":"Home","title":"MQDT.good_quantum_number","text":"good_quantum_number(T::lsChannels)\ngood_quantum_number(T::jjChannels)\ngood_quantum_number(T::fjChannels)\n\nGiven a ls or jj (fj) channel representation, this function checks whether each channel has the same total (hyperfine) angular momentum J (F) and, if true, returns it.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.kbar-Tuple{Number}","page":"Home","title":"MQDT.kbar","text":"kbar(M::Number) = tan(π * M)\nkbar(M::Vector{Float64}) = diagm(kbar.(M))\nkbar(N::Number, M::fModel, P::Parameters)\n\nFunction that returns the K matrix in the close-coupling frame, i.e. in its diagonal representation\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.kmat-Tuple{Number, fModel, Parameters}","page":"Home","title":"MQDT.kmat","text":"kmat(N::Number, M::fModel, P::Parameters)\nkmat(N::Number, M::kModel, P::Parameters)\n\nFunction that returns the K matrix in the fragmentation frame.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.magnetic_matrix_cached-Tuple{Any, Any, Any, MQDT.Channels, MQDT.Channels}","page":"Home","title":"MQDT.magnetic_matrix_cached","text":"See also magneton\n\nmagnetic_matrix_cached(nd, mp, ic, k1::Channels, k2::Channels)\n\nIterates magneton over Channels, returns a matrix. This function is cached using the LRUCache package.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.magneton-Tuple{Any, Any, Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.magneton","text":"magneton(nd, mp, ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\nmagneton(nd, mp, ic, q1::jjQuantumNumbers, q2::jjQuantumNumbers)\n\nReturns the reduced magnetic dipole moment (excluding radial contributions from the Rydberg electron)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.mmat-Tuple{Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.mmat","text":"mmat(N::Number, M::Model, P::Parameters)\n\nFunction that returns the M matrix.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.mroots-Tuple{Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.mroots","text":"mroots(N::Number, M::Model, P::Parameters)\nmroots(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns the roots of the M matrix in the range from N to N+1 or, if provided, from N1 to N2. Root finding algorithm used from the package Roots.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.multipole_moments-Tuple{MQDT.BasisState, MQDT.BasisState, Parameters}","page":"Home","title":"MQDT.multipole_moments","text":"multipole_moment(s1::BasisState, s2::BasisState, P::Paramaters)\n\nReturns the reduced matrix elements for electric dipole, electric quadrupole, magnetic dipole, and electric dipole squared.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.nu-Tuple{Number, Vector, Number, Number}","page":"Home","title":"MQDT.nu","text":"nu(N::Number, T::Vector, I::Number, R::Number)\nnu(N::Number, M::Model, P::Parameters)\nnu(N::Vector, M::Model, P::Parameters)\n\nGiven a principal quantum number, return the channel-dependent principal quantum numbers, depending on the channel thresholds and the Rydberg constant.\n\nExamples\n\nMQDT.nu(60, [50442.795744, 83967.7, 80835.39, 77504.98, 50443.217463], 50443.217463, 109736.9635066)\n\n# output\n\n5-element Vector{Float64}:\n 60.41940064523729\n  1.80841488964728\n  1.8992315361002043\n  2.0125837973909384\n 60.0\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.parity-Tuple{MQDT.Channels}","page":"Home","title":"MQDT.parity","text":"See also unique_parity\n\nparity(T::Channels)\n\nGiven a channel representation, this function returns the parity of a each channel based of the orbital angular momenta of the core and the Rydberg electron.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.radial_matrix-Tuple{MQDT.BasisState, MQDT.BasisState, Int64}","page":"Home","title":"MQDT.radial_matrix","text":"See also radial_moment_cached\n\nfunction radial_matrix(s1::BasisState, s2::BasisState, order::Int)\n\nEvaluates radial_moment over two BasisStates, returns a matrix, where each entry corresponds to a pair of sqdt states from the two BasisStates.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.radial_moment_cached-Tuple{Symbol, Float64, Int64, Float64, Int64, Int64}","page":"Home","title":"MQDT.radial_moment_cached","text":"radial_moment_cached(species::Symbol, nu1::Float64, l1::Int, nu2::Float64, l2::Int, order::Int)\n\nCalculate the radial matrix element using the python rydstate package. This function is cached using the LRUCache package.\n\nExamples\n\nradial_moment = MQDT.radial_moment_cached(:Yb174, 70.2667, 1, 71.2638, 2, 1)\nisapprox(radial_moment, 1712.16; rtol=1e-5)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.rot-Tuple{Number, String, Int64}","page":"Home","title":"MQDT.rot","text":"rot(T::Number, C::String, D::Int)\nrot(T::Vector, C::Vector{String}, D::Int)\nrot(N::Number, M::fModel, P::Parameters)\n\nFunction that returns a rotation matrix of dimensions D with rotation angle T. Works for subsequent rotations passed as vectors.\n\nExamples\n\nprintln(MQDT.rot(0.4, \"23\", 3))\nprintln(MQDT.rot([0.4, 0.2], [\"23\", \"12\"], 3))\n\n# output\n\n[1.0 0.0 0.0; 0.0 0.9210609940028851 -0.3894183423086505; 0.0 0.3894183423086505 0.9210609940028851]\n[0.9800665778412416 -0.19866933079506122 0.0; 0.18298657129998708 0.90270109637546 -0.3894183423086505; 0.07736548146578168 0.3816559020950483 0.9210609940028851]\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.square_brakets-Tuple{Vector}","page":"Home","title":"MQDT.square_brakets","text":"square_brakets(a::Vector) = sqrt(prod(2a.+1))\n\nAuxiliary function to calculate angular overlaps (Robicheaux2018 Eq. 11)\n\nExamples\n\nMQDT.square_brakets([1, 2, 3])\n\n# output\n\n10.246950765959598\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.theta-Tuple{Number, Matrix}","page":"Home","title":"MQDT.theta","text":"See also theta_rr\n\ntheta(N::Number, M::Matrix)\ntheta(N::Vector, M::Matrix)\n\nGiven M contains quantum defect parameters, where the k-th column represents the (k-1)st order of energy dependence, this function returns the specific quantum defect at principal quantum number N, where N can also be a list.\n\nExamples\n\nMQDT.theta(60, [0.4 10 100; 0.4 1 0])\n\n# output\n\n2-element Vector{Float64}:\n 0.4027854938271605\n 0.4002777777777778\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.theta_rr-Tuple{Number, Matrix, Int64}","page":"Home","title":"MQDT.theta_rr","text":"See also theta\n\ntheta_rr(N::Number, M::Matrix, index::Int)\n\nSimilar to theta, but here the energy dependence is assumed to be according to the Rydberg-Ritz formula. Given M contains quantum defect parameters, where the k-th column represents the (k-1)st order of energy dependence, this function returns the specific quantum defect at principal quantum number N, where N can also be a list.\n\nExamples\n\nMQDT.theta_rr(60, [0.4 10 100; 0.4 1 0], 1)\n\n# output\n\n0.4028231137913411\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.transform-Tuple{Number, fModel, Parameters}","page":"Home","title":"MQDT.transform","text":"transform(N::Number, M::fModel, P::Parameters)\n\nFunction that returns the frame transformation matrix from close-coupling to fragmentation frame.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.unique_parity-Tuple{MQDT.Channels}","page":"Home","title":"MQDT.unique_parity","text":"See also parity\n\nunique_parity(T::Channels)\n\nGiven a channel representation, this function checks the parity of each channel and returns it in case each channel has the same parity.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.Λ-Tuple{Any}","page":"Home","title":"MQDT.Λ","text":"Λ(x) = sqrt((2x+1) * (x+1) * x)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\nExamples\n\nMQDT.Λ(5)\n\n# output\n\n18.16590212458495\n\n\n\n\n\n","category":"method"}]
}
