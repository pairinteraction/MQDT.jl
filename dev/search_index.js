var documenterSearchIndex = {"docs":
[{"location":"#MQDT","page":"Home","title":"MQDT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MQDT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MQDT.BasisArray","page":"Home","title":"MQDT.BasisArray","text":"See also basisarray, BasisState\n\nBasisArray(states::Vector{BasisState})\n\nType to store a basis. A basis is a list of BasisState types, typically corresponding to different Rydberg series. BasisArray is generated by the basisarray function using lists of Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.BasisState","page":"Home","title":"MQDT.BasisState","text":"See also basisarray, BasisArray, EigenStates\n\nBasisState(energy::Float64, parity::Int, f::Float64, nu::Vector{Float64}, lr::Vector{Int}, S::Vector{Float64}, coeff::Vector{Float64}, channels::Channels)\n\nType to store all relevant information of multi-channel bound states for a given Rydberg series. BasisState is generated by the basisarray function using a Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Channels","page":"Home","title":"MQDT.Channels","text":"See also lsChannels, jjChannels, fjChannels\n\nAbstract type to store the quantum numbers of an MQDT channel representation.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.DataBaseArray","page":"Home","title":"MQDT.DataBaseArray","text":"See also DataBaseState, databasearray, basisarray, BasisArray\n\nDataBaseArray(states::Vector{DataBaseState})\n\nType to store a bound state data as a list of DataBaseState types as used by the PAIRINTERACTION software. DataBaseArray is generated by the databasearray function using lists of Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.DataBaseState","page":"Home","title":"MQDT.DataBaseState","text":"See also databasearray, DataBaseArray, EigenStates, BasisState\n\nDataBaseState(nu::Float64, parity::Int, f::Float64, nui::Vector{Float64}, nui_all::Vector{Float64}, ai::Vector{Float64}, ai_all::Vector{Float64},\n    S::Vector{Float64}, L::Vector{Float64}, J::Vector{Float64}, lr::Vector{Int}, Jr::Vector{Float64}, neg::Float64)\n\nType to store all relevant to the PAIRINTERACTION database for a given Rydberg series. DataBaseState is generated by the databasearray function using a Model and EigenStates.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.EigenStates","page":"Home","title":"MQDT.EigenStates","text":"See also eigenstates, BasisState\n\nEigenStates(n::Vector{Float64}, nu::Matrix{Float64}, a::Matrix{Float64})\n\nType to store multi-channel bound states. n is a global energy reference to a global threshold specified in the Parameters type. nu is the principal quantum number in each channel with respect to the channel-specific threshold. a is the coefficient of each channel contributing to the bound state. EigenStates is populated by the eigenstates function.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Model","page":"Home","title":"MQDT.Model","text":"See also fModel, kModel\n\nAbstract type to store MQDT models.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.Parameters","page":"Home","title":"MQDT.Parameters","text":"Parameters(species::Symbol, mass::Float64, spin::Float64, rydberg::Float64, threshold::Float64, hyperfine::Float64, dipole::Float64)\n\nType to store relevant parameters for each atomic element. A corresponding file in the parameters folder of the mqdt module initializes this type.\n\nExamples\n\nPARA = Parameters(\n    :Yb174,\n    1822.88848628*173.9388621, # nuclear mass\n    0, # nuclear spin\n    109736.9695858, # Rydberg constant in 1/cm\n    50443.070393, # lowest ionization threshold in 1/cm\n    0, # hyperfine constant in 1/cm\n    2.1 # nuclear dipole\n)\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.QuantumNumbers","page":"Home","title":"MQDT.QuantumNumbers","text":"See also lsQuantumNumbers, jjQuantumNumbers, fjQuantumNumbers\n\nAbstract type to store the quantum numbers of an MQDT channel representation.\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fModel","page":"Home","title":"MQDT.fModel","text":"See also kModel\n\nfModel(\n    name::String,\n    size::Int,\n    terms::Vector{String},\n    core::Vector{Bool},\n    thresholds::Vector{Float64},\n    defects::Matrix{Float64},\n    mixing::Vector{String},\n    angles::Matrix{Float64},\n    lschannels::lsChannels,\n    channels::Channels,\n    unitary::Matrix{Float64}\n)\n\nType to store MQDT models inspired by [PRX 15, 011009 (2025)] using sparse K matriced and frame transformation. Contains all relevant parameters to form the K matrix and calculate the spectrum for a specific Rydberg series.\n\nExamples\n\nRYDBERG_S0 = fModel(\n    \"S J=0, ν > 2\", # fit for states 6s7s upward [Phys. Rev. X 15, 011009 (2025)]\n    6,\n    [\"6sns 1S0\", \"4f13 5d 6snl a\", \"6pnp 1S0\", \"4f13 5d 6snl b\", \"6pnp 3P0\", \"4f13 5d 6snl c\"],\n    Bool[1, 0, 1, 0, 1, 0],\n    [50443.070393, 83967.7, 80835.39, 83967.7, 77504.98, 83967.7],\n    [0.355097325 0.278368431; 0.204537279 0; 0.116394359 0; 0.295432196 0; 0.25765161 0; 0.155807042 0],\n    [\"12\", \"13\", \"14\", \"34\", \"35\", \"16\"],\n    [0.12654859 0; 0.30010744 0; 0.05703381 0; 0.11439805 0; 0.09864375 0; 0.14248210 0],\n    lsChannels([\n        lsQuantumNumbers(0.5, 0, 0, 0, 0, 0),\n        lsQuantumNumbers(0.5, 0, 1, 1, 0, 0),\n        lsQuantumNumbers(0.5, 1, 1, 1, 1, 0)]\n        ),\n    jjchannels([\n        jjQuantumNumbers(0.5, 0, 0.5, 0, 0.5, 0),\n        jjQuantumNumbers(0.5, 1, 0.5, 1, 1.5, 0),\n        jjQuantumNumbers(0.5, 1, 0.5, 1, 0.5, 0)]\n        ),\n    [1 0 0 0 0 0; 0 1 0 0 0 0; 0 0 -sqrt(2/3) 0 sqrt(1/3) 0; 0 0 0 1 0 0; 0 0 sqrt(1/3) 0 sqrt(2/3) 0; 0 0 0 0 0 1]\n)\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fjChannels","page":"Home","title":"MQDT.fjChannels","text":"See also lsChannels, jjChannels\n\nfjChannels(i::Vector{fjQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"fj\" (sometimes called \"fragmentation\") coupling scheme\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.fjQuantumNumbers","page":"Home","title":"MQDT.fjQuantumNumbers","text":"See also lsQuantumNumbers, jjQuantumNumbers\n\nfjQuantumNumbers(sc::Float64, lc::Int, Jc::Float64, Fc::Float64, lr::Int, Jr::Float64, F::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"fj\" (sometimes called \"fragmentation\") coupling scheme, i.e. core angular momentum quantum numbers are coupled to the nuclear spin to give a core hyperfine configuration (Fc) which is coupled to the total Rydberg angular momentum (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.jjChannels","page":"Home","title":"MQDT.jjChannels","text":"See also lsChannels, fjChannels\n\njjChannels(i::Vector{jjQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"jj\" coupling scheme, i.e. core and Rydberg angular momentum (AM) quantum numbers are coupled separately to give a total core AM (Jc) and total Rydberg AM (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.jjQuantumNumbers","page":"Home","title":"MQDT.jjQuantumNumbers","text":"See also lsQuantumNumbers, fjQuantumNumbers\n\njjQuantumNumbers(lc::Int, Jc::Float64, lr::Int, Jr::Float64, J::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"jj\" coupling scheme, i.e. core and Rydberg angular momentum (AM) quantum numbers are coupled separately to give a total core AM (Jc) and total Rydberg AM (Jr).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.kModel","page":"Home","title":"MQDT.kModel","text":"See also fModel\n\nkModel(\n    name::String\n    size::Int\n    terms::Vector{String}\n    jjscheme::Vector{Bool}\n    lschannels::lsChannels\n    jjchannels::jjChannels\n    thresholds::Vector{Float64}\n    K0::Matrix{Float64}\n    K1::Vector{Float64}\n)\n\nType to store MQDT models inspired by [JPB 47, 155001 (2014)] using dense, energy-dependent K matrices. Contains all relevant parameters to form the K matrix and calculate the spectrum for a specific Rydberg series.\n\nExamples\n\nKMODEL_S0 = kModel(\n    \"1S0\",\n    3,\n    [\"(5s1/2)(ns1/2)\", \"(4d5/2)(nd5/2)\", \"(4d3/2)(nd3/2)\"],\n    Bool[1, 1, 1],\n    lsChannels([\n        lsQuantumNumbers(0.5, 0, 0, 0, 0, 0),\n        lsQuantumNumbers(0.5, 0, 2, 2, 0, 0),\n        lsQuantumNumbers(0.5, 0, 2, 2, 0, 0)\n    ]),\n    jjChannels([\n        jjQuantumNumbers(0.5, 0, 0.5, 0, 0.5, 0),\n        jjQuantumNumbers(0.5, 2, 2.5, 2, 2.5, 0),\n        jjQuantumNumbers(0.5, 2, 1.5, 2, 1.5, 0)\n    ]),\n    [45932.2002, 60768.43, 60488.09],\n    [1.051261 0.3759864 -0.02365485; 0.3759864 -0.6400925 -0.0002063825; -0.02365485 -0.0002063825 3.009087],\n    [0.8763911, 0.4042584, 17.22631]\n)\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.lsChannels","page":"Home","title":"MQDT.lsChannels","text":"See also jjChannels, fjChannels\n\nlsChannels(i::Vector{lsQuantumNumbers})\n\nType to store the quantum numbers of an MQDT channel representation, here in the \"LS\" coupling scheme, i.e. core and Rydberg angular momentum quantum numbers are coupled individually to give a total spin (S) and total orbital angular momentum (L).\n\n\n\n\n\n","category":"type"},{"location":"#MQDT.lsQuantumNumbers","page":"Home","title":"MQDT.lsQuantumNumbers","text":"See also jjQuantumNumbers, fjQuantumNumbers\n\nlsQuantumNumbers(S::Float64, lc::Int, lr::Int, L::Int, J::Float64)\n\nType to store the quantum numbers of a single MQDT channel in the \"LS\" coupling scheme, i.e. core and Rydberg angular momentum quantum numbers are coupled individually to give a total spin (S) and total orbital angular momentum (L).\n\n\n\n\n\n","category":"type"},{"location":"#LinearAlgebra.nullspace-Tuple{Vector{Float64}, Matrix}","page":"Home","title":"LinearAlgebra.nullspace","text":"nullspace(n::Vector{Float64}, M::Matrix)\n\nReturns the nullspace of the M matrix, which corresponds to the channel coefficents for an MQDT bound state.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G1-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G1","text":"G1(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G2-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G2","text":"G2(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G3-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G3","text":"G3(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G4-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G4","text":"G4(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G5-Tuple{fjQuantumNumbers, fjQuantumNumbers, Any}","page":"Home","title":"MQDT.G5","text":"G5(q1::fjQuantumNumbers, q2::fjQuantumNumbers, ic)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G6-Tuple{fjQuantumNumbers, fjQuantumNumbers, Any}","page":"Home","title":"MQDT.G6","text":"G6(q1::fjQuantumNumbers, q2::fjQuantumNumbers, ic)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G7-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G7","text":"G7(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.G8-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.G8","text":"G8(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.angular_matrix-Tuple{Int64, MQDT.Channels, MQDT.Channels}","page":"Home","title":"MQDT.angular_matrix","text":"See also angular_moment\n\nangular_matrix(k::Int, k1::Channels, k2::Channels)\n\nIterates angular_moment over Channels, returns a matrix. This function is 'memoized' using the Memoize package.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.angular_moment-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.angular_moment","text":"See also angular_matrix\n\nangular_moment(k, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\nangular_moment(k, q1::jjQuantumNumbers, q2::jjQuantumNumbers)\nangular_moment(k, q1::lsQuantumNumbers, q2::lsQuantumNumbers)\n\nReturns the angular matrix elements (i.e. an analytically evaluated integral of spherical harmonics). Formula is found in Robicheaux2018 Eq. 20 and in Vaillant2014 Eq. C3\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.basisarray-Tuple{EigenStates, fModel}","page":"Home","title":"MQDT.basisarray","text":"basisarray(T::EigenStates, M::fModel)\nbasisarray(T::Vector{EigenStates}, M::Vector{fModel})\n\nFunction that generates all relevant bound-state data. Returns a BasisArray, which is a list of BasisState instances.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.beta-Tuple{Any, Any}","page":"Home","title":"MQDT.beta","text":"beta(N, L) = π .* (N .- L)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.couple-Tuple{String}","page":"Home","title":"MQDT.couple","text":"couple(C::String)\n\nFrom a string of type \"ij\", return a touple of indices (i, j). With this method, maximum for j is 10.\n\nExamples\n\nMQDT.couple(\"710\")\n(7, 10)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.databasearray-Tuple{EigenStates, fModel}","page":"Home","title":"MQDT.databasearray","text":"dbstates(T::EigenStates, M::fModel)\ndbstates(T::Vector{EigenStates}, M::Vector{fModel})\n\nFunction that generates all relevant bound-state data specifically for the PAIRINTERACTION database.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.eigenenergies-Tuple{Number, Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.eigenenergies","text":"See also mroots\n\neigenenergies(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns both the roots of the M matrix as well as the channel-dependent principal quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.eigenstates-Tuple{Number, Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.eigenstates","text":"See also eigenenergies\n\neigenstates(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns the bound states corresponding to an MQDT model in the form of an instance of EigenStates, which contains the global reference principal quantum number, the channel-dependent principal quantum numbers, as well as the channel coefficients.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_ic-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_ic","text":"element_ic(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core nuclear spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_lc-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_lc","text":"element_lc(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core orbital anugular momentum (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_lr-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_lr","text":"element_lr(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of Rydberg orbital anugular momentum (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_sc-Tuple{Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_sc","text":"element_sc(ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of core spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.element_sr-Tuple{fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.element_sr","text":"element_sr(q1::fjQuantumNumbers, q2::fjQuantumNumbers)\n\nReturns the reduced matrix element of Rydberg spin (Robicheaux2018 Eq. 24)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.epsilon-Tuple{Any, Any, Any}","page":"Home","title":"MQDT.epsilon","text":"epsilon(N, T, R)\nepsilon(N, P::Parameters)\n\nGiven a principal quantum number, return the energy, depending on the ionization thresholds and the Rydberg constant.\n\nExamples\n\nϵ = MQDT.epsilon(60, 50443.217463, 109736.9635066)\n50412.734973137056\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.get_rydberg_state_cached-Tuple{Any, Any, Any}","page":"Home","title":"MQDT.get_rydberg_state_cached","text":"Get a cached rydberg state from the ryd-numerov package (where the wavefunction was already calculated) or create a new one.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.good_quantum_number-Tuple{lsChannels}","page":"Home","title":"MQDT.good_quantum_number","text":"good_quantum_number(T::lsChannels)\ngood_quantum_number(T::jjChannels)\ngood_quantum_number(T::fjChannels)\n\nGiven a ls or jj (fj) channel representation, this function checks whether each channel has the same total (hyperfine) angular momentum J (F) and, if true, returns it.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.kbar-Tuple{Number}","page":"Home","title":"MQDT.kbar","text":"kbar(M::Number) = tan(π * M)\nkbar(M::Vector{Float64}) = diagm(kbar.(M))\nkbar(N::Number, M::fModel, P::Parameters)\n\nFunction that returns the K matrix in the close-coupling frame, i.e. in its diagonal representation\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.kmat-Tuple{Number, fModel, Parameters}","page":"Home","title":"MQDT.kmat","text":"kmat(N::Number, M::fModel, P::Parameters)\nkmat(N::Number, M::kModel, P::Parameters)\n\nFunction that returns the K matrix in the fragmentation frame.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.magnetic_dipole_moment-Tuple{Any, Any, Any, MQDT.BasisState, MQDT.BasisState}","page":"Home","title":"MQDT.magnetic_dipole_moment","text":"See also multipole_moment, special_quadrupole_moment\n\nmagnetic_dipole_moment(nd, mp, ic, s1::BasisState, s2::BasisState)\n\nReturns the reduced magentic dipole moment matrix elements of multi-channel wave functions, relevant for the Zeeman Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.magnetic_matrix-Tuple{Any, Any, Any, MQDT.Channels, MQDT.Channels}","page":"Home","title":"MQDT.magnetic_matrix","text":"See also magneton\n\nmagnetic_matrix(nd, mp, ic, k1::Channels, k2::Channels)\n\nIterates magneton over Channels, returns a matrix. This function is 'memoized' using the Memoize package.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.magneton-Tuple{Any, Any, Any, fjQuantumNumbers, fjQuantumNumbers}","page":"Home","title":"MQDT.magneton","text":"magneton(nd, mp, ic, q1::fjQuantumNumbers, q2::fjQuantumNumbers)\nmagneton(nd, mp, ic, q1::jjQuantumNumbers, q2::jjQuantumNumbers)\n\nReturns the reduced magnetic dipole moment (excluding radial contributions from the Rydberg electron)\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.matrix_data-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Home","title":"MQDT.matrix_data","text":"See also state_data\n\nmatrix_data(T::SparseMatrixCSC{Float64, Int64})\n\nStore a reduced matrix elements as a data frame as used by the PAIRINTERACTION software.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.matrix_element-Tuple{Int64, BasisArray}","page":"Home","title":"MQDT.matrix_element","text":"See also multipole_moment, magnetic_dipole_moment, special_quadrupole_moment\n\nmatrix_element(k::Int, B::BasisArray)\nmatrix_element(B::BasisArray)\nmatrix_element(A::Parameters, B::BasisArray)\n\nIterates multipole_moment, magnetic_dipole_moment, and special_quadrupole_moment over a list of states passed as BasisArray in order to calculate reduced elements.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.mmat-Tuple{Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.mmat","text":"mmat(N::Number, M::Model, P::Parameters)\n\nFunction that returns the M matrix.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.mroots-Tuple{Number, MQDT.Model, Parameters}","page":"Home","title":"MQDT.mroots","text":"mroots(N::Number, M::Model, P::Parameters)\nmroots(N1::Number, N2::Number, M::Model, P::Parameters)\n\nFunction that returns the roots of the M matrix in the range from N to N+1 or, if provided, from N1 to N2. Root finding algorithm used from the package Roots.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.multipole_moment-Tuple{Int64, MQDT.BasisState, MQDT.BasisState}","page":"Home","title":"MQDT.multipole_moment","text":"See also magnetic_dipole_moment, special_quadrupole_moment\n\nmultipole_moment(k::Int, s1::BasisState, s2::BasisState)\n\nReturns the reduced electric multipole matrix elements of order k of multi-channel wave functions.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.nu-Tuple{Number, Vector, Number, Number}","page":"Home","title":"MQDT.nu","text":"nu(N::Number, T::Vector, I::Number, R::Number)\nnu(N::Number, M::Model, P::Parameters)\nnu(N::Vector, M::Model, P::Parameters)\n\nGiven a principal quantum number, return the channel-dependent principal quantum numbers, depending on the channel thresholds and the Rydberg constant.\n\nExamples\n\nMQDT.nu(60, [50442.795744, 83967.7, 80835.39, 77504.98, 50443.217463], 50443.217463, 109736.9635066)\n5-element Vector{Float64}:\n 60.41940064523729\n  1.80841488964728\n  1.8992315361002043\n  2.0125837973909384\n 60.0\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.parity-Tuple{MQDT.Channels}","page":"Home","title":"MQDT.parity","text":"See also unique_parity\n\nparity(T::Channels)\n\nGiven a channel representation, this function returns the parity of a each channel based of the orbital angular momenta of the core and the Rydberg electron.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.radial_matrix-Tuple{Int64, Vararg{Any, 4}}","page":"Home","title":"MQDT.radial_matrix","text":"See also radial_moment\n\nfunction radial_matrix(k::Int, n1, n2, l1, l2)\n\nEvaluates radial_moment over lists.\n\nExamples\n\nMQDT.radial_matrix(1, [30, 30], [31, 31], [1, 2], [2, 1])\n2×2 Matrix{Float64}:\n  329.781  -302.282\n -302.278   276.085\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.radial_moment-Tuple{Int64, Vararg{Any, 4}}","page":"Home","title":"MQDT.radial_moment","text":"radial_moment(order::Int, n1, n2, l1, l2)\n\nCalculate the radial matrix element using the python ryd-numerov package.\n\nExamples\n\nMQDT.radial_moment(1, 30, 31, 1, 2)\n329.78054480806406\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.rot-Tuple{Number, String, Int64}","page":"Home","title":"MQDT.rot","text":"rot(T::Number, C::String, D::Int)\nrot(T::Vector, C::Vector{String}, D::Int)\nrot(N::Number, M::fModel, P::Parameters)\n\nFunction that returns a rotation matrix of dimensions D with rotation angle T. Works for subsequent rotations passed as vectors.\n\nExamples\n\nMQDT.rot(0.4, \"23\", 3)\n3×3 Matrix{Float64}:\n 1.0  0.0        0.0\n 0.0  0.921061  -0.389418\n 0.0  0.389418   0.921061\n\nMQDT.rot([0.4, 0.2], [\"23\", \"12\"], 3)\n3×3 Matrix{Float64}:\n 0.980067   -0.198669   0.0\n 0.182987    0.902701  -0.389418\n 0.0773655   0.381656   0.921061\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.special_quadrupole_moment-Tuple{MQDT.BasisState, MQDT.BasisState}","page":"Home","title":"MQDT.special_quadrupole_moment","text":"See also multipole_moment, magnetic_dipole_moment\n\nspecial_quadrupole_moment(s1::BasisState, s2::BasisState)\n\nReturns the special electric quadrupole moment matrix elements (i.e. r^2Y_{00}) of multi-channel wave functions, relevant for the diamagnetic Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.square_brakets-Tuple{Vector}","page":"Home","title":"MQDT.square_brakets","text":"square_brakets(a::Vector) = sqrt(prod(2a.+1))\n\nAuxiliary function to calculate angular overlaps (Robicheaux2018 Eq. 11)\n\nExamples\n\nMQDT.square_brakets([1, 2, 3])\n10.246950765959598\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.state_data-Tuple{BasisArray, Parameters}","page":"Home","title":"MQDT.state_data","text":"See also matrix_data\n\nstate_data(T::BasisArray, P::Parameters)\nstate_data(T::DataBaseArray, P::Parameters)\n\nStore a bound state data as a data frame as used by the PAIRINTERACTION software.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.theta-Tuple{Number, Matrix}","page":"Home","title":"MQDT.theta","text":"See also theta_rr\n\ntheta(N::Number, M::Matrix)\ntheta(N::Vector, M::Matrix)\n\nGiven M contains quantum defect parameters, where the k-th column represents the (k-1)st order of energy dependence, this function returns the specific quantum defect at principal quantum number N, where N can also be a list.\n\nExamples\n\nMQDT.theta(60, [0.4 10 100; 0.4 1 0])\n2-element Vector{Float64}:\n 0.4027854938271605\n 0.4002777777777778\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.theta_rr-Tuple{Number, Matrix, Int64}","page":"Home","title":"MQDT.theta_rr","text":"See also theta\n\ntheta_rr(N::Number, M::Matrix, index::Int)\n\nSimilar to theta, but here the energy dependence is assumed to be according to the Rydberg-Ritz formula. Given M contains quantum defect parameters, where the k-th column represents the (k-1)st order of energy dependence, this function returns the specific quantum defect at principal quantum number N, where N can also be a list.\n\nExamples\n\nMQDT.theta_rr(60, [0.4 10 100; 0.4 1 0], 1)\n0.4002815188505022\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.transform-Tuple{Number, fModel, Parameters}","page":"Home","title":"MQDT.transform","text":"transform(N::Number, M::fModel, P::Parameters)\n\nFunction that returns the frame transformation matrix from close-coupling to fragmentation frame.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.tri_to_full-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"MQDT.tri_to_full","text":"See also matrix_data\n\ntri_to_full(M::DataFrame, S::DataFrame)\n\nConverts a reduced matrix elements data frame storing the upper triangle to a data frame storing the full matrix including the wigner phase convention (-1)^(ffinal-finitial).\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.unique_parity-Tuple{MQDT.Channels}","page":"Home","title":"MQDT.unique_parity","text":"See also parity\n\nunique_parity(T::Channels)\n\nGiven a channel representation, this function checks the parity of each channel and returns it in case each channel has the same parity.\n\n\n\n\n\n","category":"method"},{"location":"#MQDT.Λ-Tuple{Any}","page":"Home","title":"MQDT.Λ","text":"Λ(x) = sqrt((2x+1) * (x+1) * x)\n\nAuxiliary function to calculate reduced matrix elements for the magnetic moment (Robicheaux2018 Eq. 25)\n\nExamples\n\nMQDT.Λ(5)\n18.16590212458495\n\n\n\n\n\n","category":"method"}]
}
